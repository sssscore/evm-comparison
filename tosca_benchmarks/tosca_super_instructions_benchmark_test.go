// Tosca LFVM Super Instructions Benchmark Test
// Comprehensive benchmarking of super instruction patterns with different configurations
package main

import (
	"encoding/hex"
	"fmt"
	"testing"

	"github.com/0xsoniclabs/tosca/go/interpreter/lfvm"
	"github.com/0xsoniclabs/tosca/go/tosca"
)

// Test patterns that benefit from super instructions
var superInstructionPatterns = map[string]string{
	// Stack Manipulation Super Instructions
	"SWAP1_POP":        "60016002809150600360048091506005600680915060076008809150600960108091506000", // Multiple SWAP1_POP
	"POP_POP":          "6001600250506003600450506005600650506007600850506009600a50506000",           // Multiple POP_POP
	"SWAP2_SWAP1":      "60016002600391906004600560069190600760086009919060106011601291906000",       // Multiple SWAP2_SWAP1
	"SWAP2_POP":        "60016002600392506004600592506006600792506008600992506010601192506000",       // Multiple SWAP2_POP

	// Control Flow Super Instructions
	"POP_JUMP":         "6010506056600c565b6001601c565b6002602c565b60006035565b6001600101005b6000", // POP + JUMP patterns
	"PUSH2_JUMP":       "6100565b6001601c6100565b6002602c6100565b60006035565b6000",                   // PUSH2 + JUMP
	"PUSH2_JUMPI":      "600161005760026020576003603057600460405760006045565b6000",                 // PUSH2 + JUMPI
	"ISZERO_PUSH2_JUMPI": "60001561005760011561205760021562005760031563005760006000",             // ISZERO + PUSH2 + JUMPI

	// Memory Operations Super Instructions
	"DUP2_MSTORE":      "600160028152600360048152600560068152600760088152600960108152600060005160205160405160605160805160a05160c05160e0516000", // Multiple DUP2_MSTORE

	// Arithmetic Super Instructions
	"PUSH1_ADD":        "6001600101600201600301600401600501600601600701600801600901600a01600b01600c01600d01600e01600f01601001601101601201601301601401601501601601601701601801601901601a01601b01601c01601d01601e01601f01602001600050505050505050505050505050505050505050505050505050505050505050505050505050506000", // Multiple PUSH1_ADD
	"PUSH1_SHL":        "6001601b6002601b6003601b6004601b6005601b6006601b6007601b6008601b6009601b600a601b600b601b600c601b600d601b600e601b600f601b6010601b60115050505050505050505050505050506000", // Multiple PUSH1_SHL
	"DUP2_LT":          "6001600281106003600481106005600681106007600881106009601081105050505050506000", // Multiple DUP2_LT

	// Complex Multi-Instruction Super Instructions
	"SWAP2_SWAP1_POP_JUMP":      "600160026003919050566005600660079190505660086009601091905056600b600c600d9190505660006000",                 // Complex pattern
	"SWAP1_POP_SWAP2_SWAP1":     "60016002600380915091906004600560068091509190600760086009809150919060106011601280915091906000",           // Complex stack ops
	"POP_SWAP2_SWAP1_POP":       "60016002600350919050600460056006509190506007600860095091905060106011601250919050600060006000",         // Complex cleanup
	"AND_SWAP1_POP_SWAP2_SWAP1": "600f601016809150919060ff60201680915091906001600281680915091906003600481680915091906000",              // Bitwise + stack

	// Constant Loading Super Instructions
	"PUSH1_PUSH1":      "60016002600360046005600660076008600960106011601260136014601560166017601860196020600050505050505050505050505050505050505050505050506000", // Multiple PUSH1_PUSH1
	"PUSH1_DUP1":       "6001806002806003806004806005806006806007806008806009806010806011806012806013806014806015806016806017806018806019806020805050505050505050505050505050505050505050505050505050505050505050506000", // Multiple PUSH1_DUP1

	// Complex Real-World Patterns
	"FUNCTION_CALL_CLEANUP":   "60016002600391805091906004600560068091509190600760086009809150919060106011601280915091905050505050506000",     // Function epilogue pattern
	"LOOP_COUNTER_PATTERN":    "6001600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600101600150505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050506000", // Heavy loop pattern
	"MEMORY_COPY_PATTERN":     "600160008152602060208152604060408152606060608152608060808152602060006020600037604060206040604037606060406060606037608060606080608037600060805160605160405160205160005160c05160a05160805160605160405160205160005160c05160a05160805160605160405160205160005160c05160a051608051606051604051602051600051600050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050506000", // Memory operations

	// Edge Cases for Super Instructions
	"MIXED_SUPER_PATTERNS":    "600160028091506003600481526005600682526007600810600901600a1b600b600c91906000", // Mixed super instruction types
	"NESTED_SUPER_PATTERNS":   "600160026003919080915060046005600691908091506007600860099190809150600a600b600c919080915060006000", // Nested patterns
	"CASCADING_SUPER_INSTR":   "600160020180915060036004815260056006825260076008109060090160001b600c600d9190506000", // Cascading optimizations
}

// Benchmark standard LFVM interpreter (no super instructions)
func BenchmarkStandardLFVM(b *testing.B) {
	interpreter, err := lfvm.NewInterpreter(lfvm.Config{})
	if err != nil {
		b.Fatalf("Failed to create standard LFVM interpreter: %v", err)
	}

	for name, hexCode := range superInstructionPatterns {
		b.Run(name, func(b *testing.B) {
			code, err := hex.DecodeString(hexCode)
			if err != nil {
				b.Fatalf("Failed to decode %s: %v", name, err)
			}

			b.ResetTimer()
			for i := 0; i < b.N; i++ {
				params := tosca.Parameters{
					Gas:  100000,
					Code: code,
				}
				_, _ = interpreter.Run(params)
			}
		})
	}
}

// Benchmark conversion performance with different configurations
func BenchmarkConversionPerformance(b *testing.B) {
	testCodes := []struct {
		name string
		code string
	}{
		{"Simple", "6001600201600301600050505006000"},
		{"SWAP1_POP_Heavy", superInstructionPatterns["SWAP1_POP"]},
		{"PUSH1_ADD_Heavy", superInstructionPatterns["PUSH1_ADD"]},
		{"Complex_Mixed", superInstructionPatterns["MIXED_SUPER_PATTERNS"]},
	}

	b.Run("WithoutSuperInstructions", func(b *testing.B) {
		converter, err := lfvm.NewConverter(lfvm.ConversionConfig{
			WithSuperInstructions: false,
		})
		if err != nil {
			b.Fatalf("Failed to create converter: %v", err)
		}

		for _, tc := range testCodes {
			b.Run(tc.name, func(b *testing.B) {
				code, _ := hex.DecodeString(tc.code)
				codeHash := &tosca.Hash{}
				hashBytes := []byte(tc.name)
				paddedBytes := make([]byte, 32)
				if len(hashBytes) > 32 {
					copy(paddedBytes, hashBytes[:32])
				} else {
					copy(paddedBytes, hashBytes)
				}
				copy(codeHash[:], paddedBytes)

				b.ResetTimer()
				for i := 0; i < b.N; i++ {
					_, _ = converter.Convert(code, codeHash)
				}
			})
		}
	})

	b.Run("WithSuperInstructions", func(b *testing.B) {
		converter, err := lfvm.NewConverter(lfvm.ConversionConfig{
			WithSuperInstructions: true,
		})
		if err != nil {
			b.Fatalf("Failed to create converter: %v", err)
		}

		for _, tc := range testCodes {
			b.Run(tc.name, func(b *testing.B) {
				code, _ := hex.DecodeString(tc.code)
				codeHash := &tosca.Hash{}
				hashBytes := []byte(tc.name)
				paddedBytes := make([]byte, 32)
				if len(hashBytes) > 32 {
					copy(paddedBytes, hashBytes[:32])
				} else {
					copy(paddedBytes, hashBytes)
				}
				copy(codeHash[:], paddedBytes)

				b.ResetTimer()
				for i := 0; i < b.N; i++ {
					_, _ = converter.Convert(code, codeHash)
				}
			})
		}
	})
}

// Benchmark real-world contract patterns
func BenchmarkRealWorldPatterns(b *testing.B) {
	// Patterns extracted from real smart contracts
	realWorldPatterns := map[string]string{
		// ERC20 transfer function pattern
		"ERC20_Transfer": "6000357fffffffff0000000000000000000000000000000000000000000000000000000016806370a082311461006957806395d89b41146100a0578063a9059cbb146100ca578063dd62ed3e146101035763f2fde38b14610136576000600060405180910390fd5b61009c60048036036020811015610080575f80fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff16906020019092919050505061016f565b5050005b6100c860048036036040811015610b7575f80fd5b8101908080359060200190929190803590602001909291905050506001b5565b005b610101600480360360408110156100e1575f80fd5b8101908080359060200190929190803590602001909291905050506102b8565b005b61013460048036036040811015610m9575f80fd5b81019080803590602001909291908035906020019092919050505061041a565b005b6100c860048036036020811015610400575f80fd5b8101908080359060200190929190505050610460565b005b505050",

		// Contract creation pattern
		"Contract_Creation": "608060405234801561001057600080fd5b506040516020806108a08339810180604052810190808051906020019092919050505080600090805190602001906100499291906100de565b5050600160026000600173ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a81548160ff0219169083151502179055505b005b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f1061011f57805160ff191683800117855561014c565b8280016001018555821561014c579182015b8281111561014b578251825591602001919060010190610130565b5b50905061015991906101dd565b50905b6101fa565b808211156101f65760008160009055506001016101e0565b5090",

		// Complex arithmetic operations from DeFi contracts
		"DeFi_Calculations": "6000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff16806318160ddd1461006c578063313ce5671461009757806370a08231146100c857806395d89b41146100ff578063a9059cbb1461012f578063dd62ed3e1461017c57005b34801561007857600080fd5b506100816101f3565b6040518082815260200191505060405180910390f35b3480156100a357600080fd5b506100ac6101f9565b604051808260ff1660ff16815260200191505060405180910390f35b3480156100d457600080fd5b506100e960048036038101908080359060200190929190505050610202565b6040518082815260200191505060405180910390f35b34801561010b57600080fd5b5061011461024a565b6040518080602001828103825283818151815260200191508051906020019080838360005b83811015610154578082015181840152602081019050610139565b50505050905090810190601f1680156101815780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b34801561013b57600080fd5b5061019d6004803603810190808035906020019092919080359060200190929190505050610252565b604051808215151515815260200191505060405180910390f35b3480156101a957600080fd5b506101db60048036038101908080359060200190929190803590602001909291905050506103c7565b604051808215151515815260200191505060405180910390f35b",

		// Gas optimization patterns
		"Gas_Optimized": "600160005260206000f35b600060405180910390fd5b6000819050600081111561001e5760016000808282540192505081905550005b50565b",
	}

	// Test with all four configurations
	configurations := []struct {
		name        string
		interpreter tosca.Interpreter
	}{}

	// Standard LFVM
	stdInterpreter, err := lfvm.NewInterpreter(lfvm.Config{})
	if err != nil {
		b.Fatalf("Failed to create standard interpreter: %v", err)
	}
	configurations = append(configurations, struct {
		name        string
		interpreter tosca.Interpreter
	}{"Standard", stdInterpreter})

	// LFVM with super instructions
	err = lfvm.RegisterExperimentalInterpreterConfigurations()
	if err == nil {
		siInterpreter, err := tosca.NewInterpreter("lfvm-si", nil)
		if err == nil {
			configurations = append(configurations, struct {
				name        string
				interpreter tosca.Interpreter
			}{"SuperInstructions", siInterpreter})
		}
	}

	for _, config := range configurations {
		b.Run(config.name, func(b *testing.B) {
			for patternName, hexCode := range realWorldPatterns {
				b.Run(patternName, func(b *testing.B) {
					code, err := hex.DecodeString(hexCode)
					if err != nil {
						b.Skipf("Failed to decode %s: %v", patternName, err)
						return
					}

					b.ResetTimer()
					for i := 0; i < b.N; i++ {
						params := tosca.Parameters{
							Gas:  500000, // Higher gas for complex contracts
							Code: code,
						}
						_, _ = config.interpreter.Run(params)
					}
				})
			}
		})
	}
}

// Benchmark instruction frequency analysis
func BenchmarkInstructionFrequency(b *testing.B) {
	interpreter, err := lfvm.NewInterpreter(lfvm.Config{})
	if err != nil {
		b.Fatalf("Failed to create LFVM interpreter: %v", err)
	}

	// Test patterns based on instruction frequency in real contracts
	frequencyPatterns := map[string]string{
		// High frequency instructions (PUSH1, DUP1, SWAP1, POP)
		"HighFrequency": "6001806080915060028060809150600380608091506004806080915060058060809150600680608091506007806080915060088060809150600980608091506010806080915050505050505050505050505050505050506000",
		
		// Medium frequency (ADD, SUB, MUL, DIV, MOD)
		"MediumFrequency": "600160020160030260040460050860060960070a60080b60090c60100d60110e60120f601310505050505050505050505050505050506000",
		
		// Low frequency but important (SSTORE, SLOAD, CALL, etc.)
		"LowFrequency": "600160005560026001556003600255600460035560056004556006600555600760065560086007556009600855600a6009556000600055600160015560026002556003600355600460045560056005556006600655600760075560086008556009600955600a600a55505050505050505050505050505050505050505050505050505050506000",
		
		// Mixed frequency realistic pattern
		"MixedRealistic": "6001806002018060036004026005806006048060076008066009806010086011806012096013806014906015806016916017806018926019806020936000505050505050505050505050505050505050505050505050505050505050505050505050505050506000",
	}

	for name, hexCode := range frequencyPatterns {
		b.Run(name, func(b *testing.B) {
			code, err := hex.DecodeString(hexCode)
			if err != nil {
				b.Fatalf("Failed to decode %s: %v", name, err)
			}

			b.ResetTimer()
			for i := 0; i < b.N; i++ {
				params := tosca.Parameters{
					Gas:  200000,
					Code: code,
				}
				_, _ = interpreter.Run(params)
			}
		})
	}
}

// Benchmark memory and stack stress patterns
func BenchmarkMemoryStackStress(b *testing.B) {
	interpreter, err := lfvm.NewInterpreter(lfvm.Config{})
	if err != nil {
		b.Fatalf("Failed to create LFVM interpreter: %v", err)
	}

	stressPatterns := map[string]string{
		// Stack depth stress
		"StackDepthStress": buildDeepStackPattern(100),
		
		// Memory expansion stress
		"MemoryStress": "60ff60ff5260ff6101005260ff6102005260ff6103005260ff6104005260ff6105005260ff6106005260ff6107005260ff6108005260ff6109005260ff610a005260ff610b005260ff610c005260ff610d005260ff610e005260ff610f005260ff61100052610f005160e005160d005160c005160b005160a00516090051608005160700516060051605005160400516030051602005160100516000516000",
		
		// Stack manipulation stress
		"StackManipStress": "600160026003600460056006600760086009601060118081828384858687888990919293949596979850505050505050505050505050505050505050505050505050506000",
		
		// Repeated operations stress
		"RepeatedOpsStress": buildRepeatedOperationsPattern(),
	}

	for name, hexCode := range stressPatterns {
		b.Run(name, func(b *testing.B) {
			code, err := hex.DecodeString(hexCode)
			if err != nil {
				b.Fatalf("Failed to decode %s: %v", name, err)
			}

			gasLimit := tosca.Gas(1000000) // High gas for stress tests
			
			b.ResetTimer()
			for i := 0; i < b.N; i++ {
				params := tosca.Parameters{
					Gas:  gasLimit,
					Code: code,
				}
				_, _ = interpreter.Run(params)
			}
		})
	}
}

// Helper functions for building test patterns
func buildDeepStackPattern(depth int) string {
	code := ""
	// Push values onto stack
	for i := 1; i <= depth; i++ {
		if i <= 255 {
			code += fmt.Sprintf("60%02x", i) // PUSH1
		} else {
			code += fmt.Sprintf("61%04x", i) // PUSH2
		}
	}
	// Pop all values
	for i := 0; i < depth; i++ {
		code += "50" // POP
	}
	code += "6000" // PUSH1 0
	return code
}

func buildRepeatedOperationsPattern() string {
	// Build pattern with repeated super-instruction candidates
	pattern := ""
	// Repeat PUSH1_ADD pattern
	for i := 0; i < 50; i++ {
		pattern += "600101" // PUSH1 1, ADD
	}
	// Repeat SWAP1_POP pattern
	for i := 0; i < 50; i++ {
		pattern += "600180915060" + fmt.Sprintf("%02x", i%256) // PUSH1 i, DUP1, SWAP1, POP, PUSH1 i
	}
	pattern += "50505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050506000"
	return pattern
}